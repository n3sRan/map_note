怎么理解ioe.c?

am提供了一套io设备交互的接口

程序想要与设备交互

但不同平台(例如nemu和native)的设备的架构不同 (实现方式不同)

处理这种不同的交互方式的任务不应该由程序自己承担, 也就是说, 访问设备具体的细节步骤程序是不知道的, 程序只知道自己**访问了**相关设备 (隔离/抽象)

这个任务交由AM实现 但AM只是 连接程序和平台的桥梁 所以AM就提供一套设备交互的接口 每个平台上的设备如果想**提供服务**, 就要去实现这套接口





所以编写要在AM上运行的代码 (一个程序)

如果要访问io设备

就要用到AM的库提供的函数 klib-macros 的io_read/io_write

库函数其实是对 ioe_read/ioe_write的封装

ioe_read/ioe_write是AM提供给不同平台的接口

AM也对所有设备的寄存器进行了抽象, (编号) AM_DEVICE_REG

调用函数就是 ioe_read(AM_DEVICE_REG, buf) 读出设备的内容放进buf, write则是把buf的内容写进设备

AM根据目前在运行的平台, 调用该平台自己实现的ioe_read/ioe_write

比如NEMU, 其在ioe.c中建了一个设备寄存器编号和其相关读/写函数的数组

调用ioe_read/write时就是调用对应编号设备寄存器的读/写函数

然而以上代码都是在am里的 (不同平台在am里实现自己的接口), 在平台究竟如何响应以上的函数呢

对于riscv32-nemu (mmio)来说

设备的读写不过只是内存的读写, 于是可以再添加一层抽象 (在riscv.h am目录下), 将所有设备寄存器的读写函数都去调用内存相关的读写函数 (避免编译器优化) 由于寄存器一般比较小, 所以可以定义out/in函数

至此, 访问i/o设备的操作, 在编译器看来, 就成了访存操作, 从程序的视角看, 程序运行时与设备交互不过只是读/写内存而已 至于访存后发生了什么, 就是硬件自己的事了

我们在NEMU (CPU + 内存 + 设备)下干的事, 就是

如何确定自己是访问内存还是访问io设备

如何确定自己是访问哪个io设备

io设备被访问后要干什么



拿串口举例

向命令行输出字符等于向串口写入字符

调用AM里面的trm.c下的putch()

进而调用riscv.h下的outb()

编译后变成"写入内存的某个地址" (汇编指令: sb)

该指令在nemu中 inst.c译码, 调用vaddr_w, 进而调用paddr_w

paddr_w先检测该地址是不是内存地址

发现不是, 则判定为mmio映射的设备地址,

调用mmio.c里的mmio_write()

设备管理相关代码会先判断该地址属于哪个设备 (调用map.c里的fetch_mmio_map())

确定后再调用map.c里的map_write

map_write()函数中 会先进行数据长度 len 检查 以及地址的边界检查

然后用传入的addr和map中的low相减计算偏移量

然后调用host_write进行设备寄存器的写入

最后调用该设备的回调函数

​	回调函数接收三个参数 偏移量 (读/写了设备的哪个寄存器, 即改了设备所注册的空间的哪个位置), 长度, 写/读

​	作用是在读/写设备的寄存器后, 这个**设备**要做什么事

​	在串口中, serial.c的回调函数是serial_io_handler() 检查完后 其调用serial_putc() 在主机的标准错误流进行字符输出, 说白了就是往命令输出字符

自此, 所有事情结束, cpu执行下一条指令

### 串口

### 时钟

PA2.3要求在`abstract-machine/am/src/platform/nemu/ioe/timer.c`实现`AM_TIMER_UPTIME`功能

实际上是实现程序读这个寄存器时, 能获取系统启动后的微秒数 (即程序能正确读取时钟信息)

实际上是完成`__am_timer_uptime()`的函数 (RTFSC)

步骤: 当需要读寄存器时, 读取硬件, 获得系统启动后的微秒数, 写入缓冲区.

这个数据存放在nemu的代码中, 也就是硬件里面.

怎么读取硬件的时钟呢?  这就需要RTFSC了.

回到nemu的代码 `nemu/src/device/io/map.c`

你会发现 map_read() 中读取数据前执行了一次回调函数 (即准备了要读的数据), 而 map_write() 则是先写入数据再执行回调函数, 这个不同还是很重要的.

回到nemu的代码 `nemu/src/device/timer.c`

timer的回调函数则是调用 get_time() 获取了 uint64类型的系统启动后的微秒数, 并将低32位存入设备空间的前8个字节 (即第一个寄存器), 将高32位存入设备空间的第二个寄存器.

**比较重要的一点时 只有当传入的偏移量 offset 为4, 即读取第二个寄存器时, 设备才会准备好数据 (即更新时钟)**

这就是文档里所说的埋下的"坑". 它隐性要求我们先读高16位, 再读低16位, 才能获得真正的时间.

如果反过来呢?

因为nemu (硬件) 里存放的时间只有在你要读高16位时才会刷新, 否则存放的只是旧的时间.我们假设刚开机不久我们需要读时间

- 第一次
  - 先读低16位的时候, 时间未刷新, 硬件里存的时间为$h_0l_0$得到低16位$l_0$
  - 再读高16位时, 时间已刷新, 硬件里存的时间为$h_1l_1$, 得到高16位$h_1$, 拼接起来为$t_1 = h_1l_0$
- 第二次
  - 先读低16位的时候, 时间未刷新, 硬件里存的时间为$h_1l_1$得到低16位$l_1$
  - 再读高16位时, 时间已刷新, 硬件里存的时间为$h_2l_2$, 得到高16位$h_2$, 拼接起来为$t_1 = h_2l_1$
- 两次获得的时间均为错误时间, 导致计算时间差 (跑分需要) 时出错

回到要实现的函数`__am_timer_uptime()`	

知道了上述信息, 就可以实现I/O设备的读取了, 也就是实现内存读取

通过RTFSC, 可以发现`abstract-machine/am/src/platform/nemu/include/nemu.h`中提供了一套函数以供内存的读/写 in/out

那又怎么知道读/写的地址呢?

又通过RTFSC, 可以发现`abstract-machine/am/src/riscv/​riscv.h`中提供了一组设备的内存的地址的宏定义

有了这些就可以大展身手了!

先读`RTC_ADDR + 4`, 转成64位, 左移32位, 再读`RTC_ADDR`, 转成64位, 两者相加, 写入`uptime->us`, 大功告成!

### 键盘

在nemu实现的硬件层面`keyboard.c`中, 通过SDL库的相关函数检查键盘状态, 每当有按键被按下, 便会调用`send_key()`函数, 传入`scancode`和`is_keydown`,  随后将`scancode` (作为低16位) 和`KEYDOWN_MASK`掩码 (作为高16位) 组成uint32类型的**按键信息**传入`key_enqueue()`函数, 即将这次按键的信息放入环形缓冲区, 逻辑结构为一个队列 (先进先出)

每当读取键盘时, 先调用键盘的回调函数`i8042_data_io_handler()`, 从队列中取出一个**按键信息**, 即调用`key_dequeue()`函数, 并放在键盘的**第一个寄存器**中, 以供CPU读取.

仿照时钟的实现便可以实现键盘设备的读取了, 至于键盘的写入 (nemu的硬件层面), 则是SDL的事了.

### VGA

*文档讲的挺明白的.*

`AM_GPU_CONFIG`, 显示控制器信息, 读出屏幕大小以及屏幕同步信号.

在AM的gpu.c中, 可以发现同步信号存放在控制器的**第2个存储器**.

在NEMU的vga.c中, 可以发现屏幕的高度和宽度均为16位数字, 拼接成一个**uint32类型信息**存放在控制器的**第1个寄存器**.

同时也可以发现vga的回调函数被设置为了NULL, 即当我们往控制器写入同步信号时, `map_write()`函数并不会指挥屏幕刷新, 那么屏幕又是如何刷新的呢?

通过RTFSC可以发现在vga.c中有两个函数`vga_update_screen()`和`update_screen()`, 且TODO里说明了后者会被前者调用.

- 查看`cpu-exec.c`中的`excute()`函数, 可以发现每当执行完一次`execute_once()`函数后, 会执行一次`device_update()`函数, 函数中每隔1/60秒就会刷新一次所有设备, 其中就包含了调用`vga_update_screen()`函数 (再往下读可以发现键盘的刷新也放在这里)

- 再看看具体的刷新屏幕的实现`update_screen()`, 其中涉及到了全是SDL库的函数,简单来说就是把**vmem** (video memory, 显存)的内容搬到texture (纹理) 里, 再把texture的内容搬到 renderer (渲染器, 也可以理解为画笔), 再由 renderer 把要显示的内容画到窗口中 (被我们看到).


结合`init_vga()`函数, 里面注册了两个I/O设备, vga控制器`vgactl`和显存`vmem`, 我们可以知道, 控制信息 (告诉显示器要显示新的内容) 是存放在`vgactl`里的, 而帧信息 (告诉显示器显示什么内容) 是存放在`vmem`里的, CPU要往显示器输出信息, 就要**先**向帧缓冲区 (frame buffer, 也就是显存, 在AM被定义为AM_GPU_FBDRAW, 帧缓冲控制器) 写入信息, 即准备好画面内容, **再**向控制器写入刷新信号, 显示器自己的硬件一旦检测到刷新信号为`true`, 就将vmem的内容输出, 这样, 一帧画面就能被我们看到了.

根据以上内容回去看gpu.c的代码, 以及测试代码, 可以发现, 调用`am_gpu_config()`函数是只读的 (把内容读入cfg), 调用`am_gpu_fbdraw()`函数是只写的() (把ctl的内容写入显存, 除此之外还要往控制器写入控制信息).

写入控制信息这一步代码已经给出了, 剩下的就是把写入显存部分的代码完成了.

再看vga.c的代码, 需要完成`vga_update_screen()`中的内容, 具体步骤很简单: 如果控制信息不为0, 就调用`update_screen()`, 输出完后将控制信息设为0 (即将显示器状态设为空闲)

### 声卡