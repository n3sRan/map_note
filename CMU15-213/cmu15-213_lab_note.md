# Lab Note

## Bomb Lab

前面的忘了, 某个阶段我是根据汇编写出伪代码, 再转为c代码通过枚举法得到答案的.

### Phase 5

输入一个长度为6字符串, 取每个字符的ASCII码 (16进制) 的低位作为一个偏移量, 从而定位到内存上的一个新字符, 拼凑出新的字符串

### Phase 6

重排一个链表上的节点, 使其数字的顺序满足从大到小.

### Special Phase

进入这个Phase的条件是在第4个密码后加一个`DrEvil`, 这由汇编易得.

然后把`fun7()`的汇编转为伪代码, 再结合相关内存上的值, 可得这是一个递归形式的二叉树搜索函数, 需要给定一个搜索值, 然后返回值由搜索向左或右的次数决定. 由返回值在树上反推, 易得需要的搜索值.

## Attack Lab

难度过高, 大部分你实现都参考了两个博主:

- [不周山](<https://wdxtub.com/csapp/thick-csapp-lab-3/2016/04/16/>)
- [Arthals](<https://arthals.ink/blog/attack-lab>)

在`ctarget`中好像没有`type string`的阶段, 必须指定一个输入的文件, 一开始我在这里对比不周山的"准备工作"阶段发现不一样, 困扰了好久.

### Phase 1

简单的重定向.

### Phase 2

需要把cookie的值作为参数传入`touch2()`, 即需要向`%rdi`写入一个值, 因为是CI, 直接将汇编转为机器码写进缓冲区即可.

我在这一部分踩过的坑为误以为cookie是可变的, 即面对装有不同cookie的`ctarget`, 同一份注入的字符串依然能攻击成功, 而实际是只要自己的cookie能过即可.

### Phase 3

Phase 2的错误思维其实对Phase 2影响不大, 比较cookie就放在.data段里, 把它从内存里拿到寄存器就可以了. 但这种思路直接让我在phase 3中踩进了更大的坑中.

这里会在栈的随机位置存进cookie的字符串形式, 同时与被传入`touch3()`的参数--一个字符串的地址进行字符串匹配. 这就需要把cookie的字符串形式存进内存, 然后把该字符串的地址写进`%rdi`.

我秉持着错误的思路, 想着像`hexmatch()`一样调用一个`sprintf()`库函数来实现"不确定"的cookie的字符串转换, 无奈发现缓冲区大小不够写这么多传参调函数的汇编. (其实后来意识到这种方法也是可以的, 不过太麻烦了) 遂查看不周山的答案, 才知道我的思路错了.

另外一点我所忽略的是栈的某些空间会被覆写, 需要把"确定"的cookie字符串版本写进不会被覆写的栈空间, 然后把这个确定的内存地址写进`%rdi`就大功告成了.

### Phase 4

由于课上没看懂ROP攻击的原理只能去线下补充基础知识: [ROP入门课](<https://www.bilibili.com/video/BV1Br4y1K7ir>), 信心满满去挑战Phase 4, 结果直接倒在了寻找`push %rdi`这一步了. 看了笔记才知道, 我所在的只是汇编代码层, 而lab所要求的是在机器码层, 需要找出字节码的新的组合来获得gadget, 而不是只依靠原来的汇编语句.

很感谢Arthals提供的正则表达式清理与匹配方法, 既使得farm的每个函数的机器码能放在同一行, 以便于正则表达式的匹配. 我也跟着这位佬把坑踩完了.

### Phase 5

其实最终思路不过于把字符串放在栈里面, 把`%rsp`的值放在`%rdi`, 把`%rdi`增加一个偏移量. 第一步其实不难, 难在第二步增加这个偏移量, 我忽略了很重要的一点是可以把一个常数放在栈中, 然后将它`pop`到某个寄存器, 看了笔记才知道, 然后再把常数兜兜转转, 知道最后一条已经存在的汇编`lea (%rdi, %rsi, 1), %rax`, 来实现栈上地址与偏移量的相加.

