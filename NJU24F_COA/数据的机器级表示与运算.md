# 数据的机器级表示与运算

[TOC]

## 浮点数运算



## 二进制编码的十进制数运算

### 二进制编码的十进制数表示

- 使用原因: 精度限制
- 编码方式: 自然CBD码 (NCBD, 8421码)
  - 0~9: 0000~1001
  - 正: 1100/0
  - 负: 1101/1

### 加法

- 溢出: 但按位加法的值在[10, 19]范围内, 需要对结果进行调整, 对溢出的值加6 (二进制表示为1010)
- ![](../0_Attachment/Pasted%20image%2020241226175607.png)

### 减法

- 思路: 参照补码减法, 避免借位
- 将减数进行**反转** (加上`0110`,  再按位取反, 也可以先按位取反再加上`1010`), 然后将被减数与反转后的数相加
- 结果调整
  - 如果最高位有进位, 舍弃
  - 如果最高位没有进位, 对结果进行**反转**, 反转后的结果再加1, 并将结果符号设为负
- ![](../0_Attachment/Pasted%20image%2020241226175508.png)

## 数据校验码

### 奇偶校验码

用1位的额外位来表示数据中"1"的个数为奇数还是偶数

奇校验码: 整个校验码 (有效信息位和校验位) 中"1"的个数为奇数

偶校验码: 整个校验码 (有效信息位和校验位) 中"1"的个数为偶数

校验: 前后的奇偶校验类型必须一样

例: 偶校验 (奇校验则多异或一个1)

- 记原信息位为 $M = M_N...M_2M_1$
- 校验位为 $P = M_N \oplus ... \oplus M_2 \oplus M_1$
- 发送的数据为$PM$
- 记接收的数据为 $P'M'$, 由$M'$得到的校验位为$P''$
- 求$P'' \oplus P'$
  - 结果为0则表示数据正确, 或有偶数个位置是错误的
  - 结果为1则表示有奇数个位置是错误的 

优点: 简单, 低成本

缺点: 检错/纠错能力有限

适合校验比较短的01串 (1个字节)

### 海明校验码

将数据分配给很多组, 对每一组使用检查正误的奇偶校验码, 使得校验码既可以检查错误, 也可以定位错误位置并纠正错误.

#### 过程

- 发送数据: 将M位信息分配给P个组, 对每一个分组生成一个奇偶校验码, 一共获得P位的奇偶校验码
- 接收数据: 根据接收到的P组信息位生成P位奇偶校验码, 与接收到的校验码进行异或操作, 生成P位的故障字.
- 分配: 一个信息位可能位于多个分组中
- 故障字E: 每一位故障字也可以通过判断该组数据 (校验位+信息位) **保持奇偶校验码的特征**而需要添加0还是1而得到, 这个被添加的位就是故障位

作用域: 发现1位错误, 纠正1位错误 SEC Single-Error-Correcting

如何分组: 满足 $2^P \ge M + P + 1$, 第i个 (从1开始计数) 校验位在完整数据 (校验位+信息位) 中的第$2^i$位 (从1开始计数), 校验位下标的二进制表示只有1位为1其余为0, 其检验二进制下标同一位下同样为1的信息位.

故障字

- 全0, 没有错误
- 非全0, 完整数据的第$e_M...e_2e_1$位发生了错误, 对其取反便可纠正

海明码的码距为3

#### 原理

- 纠错理论: $L - 1 = D + C, \ D \geq C$, L为编码码距, D为检错位数, C为纠错位数
- 扩展
  - 在一个码组内要检测到X个错误位, 要求码组码距应满足: $D \ge X+1$
  - 一个码组内要纠正Y个错误位, 要求码组码距应满足: $D \ge 2Y+1$
  - 在一个码组内要纠正Y个错误位且同时能检测到X个错误位,要求码组码距立满足: $D \ge X+Y+1$

#### SEC-DED

Single-Error-Correcting, Double-Error-Detecting 发现2位错误, **并且**纠正1位错误

海明码的码距为4

满足 $2^{P-1} \ge M + P + 1 $

### 循环冗余校验码

奇偶校验法的问题: 

- 额外的代价比较大
- 需要把数据切割到每一位

解决方法: 循环冗余校验码 (Cyclic Redundancy Check, CRC) 

原理: 约定一个生成多项式并生成二进制除数, 如果数据与除数进行**模二除法**后余数为0, 说明数据正确

校验码: 用来保证数据模二除法后余数为0

过程: 根据除数的位数k, 将数据左移k-1位, 然后与除数进行模二除法运算, 将左移后的数据的低k-1位替换为**所得余数**(最多k-1位, 即校验码), 最后传输数据

模二除法: 看最高位是否为1, 是的话将**对齐**的每一位进行异或运算, 不是则将除数右移一位, 重复...

