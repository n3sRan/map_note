# 传输层

## 传输层提供的服务

### 端口

- 通过**端口号**标识本主机的一个特定**进程**
  - 注意:每台主机的**端口号是相互独立**的
  - 注意:TCP, UDP**两种协议的端口号是相互独立**的
- TCP或UDP协议, 通过Socket 套接字={ IP地址:端口号}, 唯一地标识网络中的一台主机上的一个应用进程
- 端口号的分类 (建议标准而非强制标准)
  - 服务器使用的端口号
    - 熟知端口号: 0~1023, 通常只能用于被熟知的重要应用程序
    - 登记端口号: 1024~49151
  - 客户端使用的端口号
    - 短暂端口号: 49152~65535
- ![](../0_Attachment/Pasted%20image%2020241207000149.png)

### 功能

- 实现端到端(进程到进程)的通信
- 复用和分用
  - 复用 (从上到下): 在发送数据的时候, 同一台主机上的多个进程可以使用同一个传输层协议
  - 分用 (从下到上): 在接收数据的时候, 传输层可以把数据正确交付到目的进程
- 差错检测
  - TCP检测出差错后丢弃数据, 并通知发送方重传
  - UDP检测出错误后直接丢弃数据, 且不通知发送方
- 向应用层提供两种服务
  - 面向连接的, 可靠的端到端传输服务 (TCP): 确保数据正确/完整, 但开销大, 实时性较差
  - 无连接的, 不可靠的端到端传输服务(UDP): 数据可能出错/丢失, 但速度快, 开销小

- 有连接的传输
  - 传输前先打招呼, 先确认对方已经准备好接收数据。传输结束时也要告知对方已结束
- 无连接的传输
  - 不打招呼, 直接把数据传给对方
- ![](../0_Attachment/Pasted%20image%2020241207000438.png)
- 可靠的传输
  - 接收方使用“确认机制让发送方知道哪些数据已被正确接收
- 不可靠的传输
  - 接收方无论收没收到数据, 数据是否正确, 都不给发送方反馈
- ![](../0_Attachment/Pasted%20image%2020241207000455.png)

## UDP

### UDP vs. TCP

- 首部
  - UDP首部很小, 只占8B.
  - TCP首部更大, 占20~60B
- 报文
  - UDP每次传输一个完整的报文, 不支持报文自动拆分, 重装
  - TCP支持报文自动拆分, 重装, 因此可以传输长报文
- 传输控制
  - UDP是无连接的, 不可靠的 (可靠性可以交给应用层处理), 也不支持拥塞控制
  - TCP是有连接的, 可靠的, 支持拥塞控制
- 传输对象
  - UDP支持一对一 (封装成单播IP数据报), 一对多传输(封装成广播/多播IP数据报)
  - TCP仅支持一对一传输 (因为通信双方的传输层必须先建立连接)

### UPD数据报

![](../0_Attachment/Pasted%20image%2020241207114609.png)

### UDP校验

#### 检验方法

将数据以16bit为一组, 进行二进制加法, 最高位产生的进位需要"回卷", 即加回最低位, 得到的结果逐位取反即为**校验和**. 

校验时, 如果没有比特错误, 那么以16bit为一组, 进行二进制加法 (最高位产生的进位需要"回卷"), 加法结果一定为全1. 如果发生了比特错误, 加法结果就不是全1.

![](../0_Attachment/Pasted%20image%2020241207115254.png)

#### 过程

- 发送方的传输层
  - 传输层的UDP协议在计算检验和之前, 先添加伪首部
  - 把伪首部, 首部, 数据部分以16bit为一组, 进行二进制加法 (最高位产生的进位需要回卷)
  - 将最终的加法结果逐位取反, 就得到16bit检验和, 将其填入UDP首部
  - 去掉伪首部, 并将UDP数据报交给网络层, 封装成IP数据报
  - ![](../0_Attachment/Pasted%20image%2020241207115423.png)
- 接收方的传输层
  - 网络层向传输层递交UDP数据报
  - 传输层在UDP数据报之前, 添加伪首部
  - 把伪首部, UDP首部, 数据部分以16bit为一组, 进行二进制加法 (最高位产生的进位需要回卷)
  - 如果加法结果为全1, 说明没有比特错误, 于是接收该UDP数据报, 并根据目的端口号, 向应用层递交报文. 如果加法结果不是全1, 说明有差错, 于是**丢弃**该UDP数据报
  - ![](../0_Attachment/Pasted%20image%2020241207115531.png)

## TCP

### TCP段

TCP报文段

#### TCP协议三大阶段

- 建立连接 (三次握手)
- 数据传输
- 释放连接 (四次挥手, 挥手顺序可变)
- ![](../0_Attachment/Pasted%20image%2020241207154111.png)

#### 面向字节流

- 每次建立TCP连接, 可以双向传输多个报文
- TCP是面向字节流的, 而UDP是面向报文的, 即无论传输多少个报文, 在TCP协议看来都是一连串字节流
- ![](../0_Attachment/Pasted%20image%2020241207154147.png)

#### TCP段格式

- ![](../0_Attachment/Pasted%20image%2020241207162642.png)
- 序号
  - 简记为`seq`
  - 用于标记数据部分第一个字节在原始字节流中的位置
  - 起始序号是是发送方自己设置的, 不一定从0开始
- 确认号
  - 简记为`ack`或`ack_seq`
  - 用于反馈, 表示序号在**该确认号之前的所有字节**都已正确收到
  - 累计确认机制
- ACK
  - 1bit
  - ACK=0时, `ack_seq`无效, ACK=1时, `ack seq`有效
  - 只有握手1的ACK=0, 其他所有TCP报文段ACK=1
- 数据偏移
  - 4bit, 表示TCP首部长度, 以4B为单位
  - TCP首部最长为60B
- URG
  - 1bit, 晋级位, Urgent
  - URG=1时, 紧急指针有效。表示这是紧急数据, 应尽快插队发送
  - 紧急指针: 紧急数据专用序号, 原理与**序号**字段相同
- PSH
  - 1bit, 推送位, Push
  - PSH=1时表示希望接收方尽快回复 (用于交互式通信)
- RST
  - 1bit, 复位位, Reset
  - RST=1时, 表示出现严重差错(如主机崩溃), 必须释放连接. 也可用于拒绝一个非法报文段 (如恶意的黑客攻击)
- SYN
  - 1bit
  - 当SYN为1时表示这是一个连接请求或连接接受报文.
  - 只有握手1, 握手2的SYN=1, 其他所有TCP报文段都是SYN=0
- FIN
  - 1bit
  - 当FIN为1时, 表明此报文段的发送方的数据已发送完毕, 要求释放传输连接.
  - 只有挥手1, 挥手3的FIN=1, 其他所有TCP报文段都是FIN=0
- 窗口
  - 16bit, 表示接收窗口的大小, 即从本报文段首部中的`ack_seq`算起, 接收方还能接收多少数据 (以字节为单位)
  - 实现**流量控制**的关键
  - 简记为`rwnd`或`rcvwnd`
- 校验和
  - 原理与UDP雷同, 计算检验和之前也需要添加12B的伪首部.
  - 只需将UDP 伪首部的协议字段的17改成6, UDP长度字段改成TCP长度.
- 选项
  - 可以为空, 也可以非空
  - 建立TCP连接时, 在握手1, 握手2选项中协商**MSS** (Maximum segment size, 最大段长).
  - MSS的值表示在接下来的数据传输中, 一个TCP报文段最多携带多少数据 (首部不算在内).
  - 通常MSS不会设置太大, 以免在IP层被分片.

### TCP连接管理

建立连接, 释放连接时

- SYN, ACK, FIN, seq, ack_seq 的值为多少?
- 每发出/收到一个握手/挥手报文段后, 进程的TCP状态转换
- 建立连接, 断开连接的最短耗时分析

#### 建立连接

- 三次握手
- ![](../0_Attachment/Pasted%20image%2020241207171433.png)
- 在TCP全过程中, **只有握手1, 握手2的SYN=1**
- 在TCP全过程中, **只有握手1的ACK=0**
- 握手1, 握手2**不能携带数据** (只有TCP首部), 但是**仍要消耗一个序号**
- 握手3可以携带数据, 如果不携带数据就不消耗序号
- 客户收到握手2就可以开始传送数据, 服务器收到握手3才能传送数据

#### 释放连接

- 四次挥手
- ![](../0_Attachment/Pasted%20image%2020241207171946.png)
- 在TCP全过程中, **只有挥手1, 挥手2的FIN=1**
- 挥手1, 挥手3即使不携带数据, 也要**消耗一个序号** (可以携带, 但一般不携带)
- 挥手2可以携带数据
- 挥手4**不可以携带数据**
- 客户进程收到挥手3后, 至少要倒计时2MSL后才能进入`CLOSE`状态, 如果等待期间重复收到挥手3, 就重置计时器.
- 如果服务器进程收到挥手1时, 已经没有待传送数据, 那么可以**连续发出**挥手2, 3 (即`COLSE-WAIT`, `FIN-WAIT-2`时间极短暂, 接近0)
- MSL (最长报文段寿命), 是由TCP协议规定的一个固定时间长度

### 可靠传输

#### 序号

- 进程在建立连接时确定起始序号, 数据传输过程中, 每个字节对应一个序号

#### 确认机制

- 累积确认规则
  - 如果收到`ack_seq=n`, 说明序号在n之前的所有字节都已正确接收
- 返回ACK的时机: **推迟确认**
  - 推迟时间最多不能超过0.5秒(TCP标准规定)
  - 如果自己也有数据要传送给对方, 立即返回ACK段, 并"捎带"自己的数据
  - 若连续收到两个长度为MSS的报文段, 就应该立即返回ACK段 (规避重传风险)
- 两种ACK段
  - 专门确认 (非规范术语): 个ACK段只有TCP首部, 而没有携带数据
  - **捎带确认**: 一个ACK段顺道携带了数据, 就是捎带确认

#### 重传机制

- 超时重传
  - 每发出一个报文段, 就设置一个**计时器**. 若计时器到期还没收到确认, 就重传这一报文段, 并重置计时器.
- 快重传 (冗余ACK)
  - 作用:让可能出错的报文段尽早重传, 而不是非要等到超时再重传
  - 配套机制: 立即确认
    - 每收到一个TCP报文段, 就立即返回一个ACK段
    - 即使收到一个失序报文段, 也要立即返回ACK段 (失序报文段会导致冗余ACK)
  - 当发送方连续收到三个确认号相同的冗余ACK时, 就立即重传该确认号对应的报文段
- ![](../0_Attachment/Pasted%20image%2020241208222030.png)

### 流量控制

- 接收方维持一个**接收窗口**
  - 接收窗口不能大于接收缓冲区大小
  - 接收窗口"框柱"的是接收方还允许接收的序号范围
- 发送方维持一个**发送窗口**
  - 发送窗口不能大于发送缓冲区大小
  - 发送窗口不能大于接受窗口的大小
  - 发送窗口"框住"的是发送缓冲区中, 已发送但尚未收到确认的数据, 以及可以发送但尚未发送的数据

### 拥塞控制

#### 拥塞控制 vs. 流量控制

- 流量控制: 控制端到端的数据发送量, 是**局部的**
- 拥塞控制: 控制整个网络中每台主机的数据发送量, 降低路由器负载, 是**全局的**

拥塞窗口: 简记为`cwnd`, 大小通常以MSS的倍速作为单位

发送窗口的上限值 = `min [rwnd, cwnd]`

#### 如何判断网络拥塞?

- 发出的每个报文段, 都能顺利地收到ACK确认: **不拥塞**
- 发出的报文段未能按时收到ACK, 引发**超时重传**: **严重拥塞**
  - 迅速缩小拥塞窗口
- 收到冗余ACK, 引发**快重传**: **有点拥塞**
  - 适当缩小拥塞窗口

#### 慢开始&拥塞避免

- 慢开始算法: `cwnd` 值从1开始, 每收到一个ACK, 就让 `cwnd+1` (当 `cwnd<ssthress` 时适用)
- 拥塞避免算法: 在一个RTT内, 即使收到多个ACK, 也只能让 `cwnd+1` (当 `cwnd>=ssthress` 时适用)
- ![](../0_Attachment/Pasted%20image%2020241208231331.png)

#### 快重传&快恢复

- 快重传: 当发送方收到三个确认号相同的冗余ACK时, 立即重传对应报文段
- 快恢复算法: 一旦发生快重传, 就将**阈值**, `cwnd`都设为当前`cwnd`的一半, 然后切换到为**拥塞避免算法**
- ![](../0_Attachment/Pasted%20image%2020241208231502.png)